<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Contenu | Pierre Gloaguen</title>
    <link>/courses/2020_simu_inge_num/</link>
      <atom:link href="/courses/2020_simu_inge_num/index.xml" rel="self" type="application/rss+xml" />
    <description>Contenu</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Fri, 20 Mar 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>Contenu</title>
      <link>/courses/2020_simu_inge_num/</link>
    </image>
    
    <item>
      <title>Le mouvement Brownien</title>
      <link>/courses/2020_simu_inge_num/mouvement_brownien/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/courses/2020_simu_inge_num/mouvement_brownien/</guid>
      <description>


&lt;div id=&#34;rappel-des-propriétés-du-mouvement-brownien&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Rappel des propriétés du mouvement Brownien&lt;/h1&gt;
&lt;p&gt;Pour simuler un mouvement Brownien &lt;span class=&#34;math inline&#34;&gt;\(\lbrace B(t) \rbrace_{t \geq 0}\)&lt;/span&gt;, on se rappellera que le mouvement Brownien est un processus de Markov en temps continu tel que:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;strong&gt;Initialisation:&lt;/strong&gt; B(0) = 0&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Loi de transition:&lt;/strong&gt; Pour touts temps &lt;span class=&#34;math inline&#34;&gt;\(t_2 &amp;gt; t_1\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(B(t_2) \vert B(t_1) \sim \mathcal{N}(B(t_1), t_2 - t_1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;simulation-avec-r&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Simulation avec R&lt;/h1&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse) 
# library(ggplot2); library(purrr); library(dplyr) 
# are enough if tidyverse doesn&amp;#39;t work&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nous allons maintenant coder en &lt;code&gt;R&lt;/code&gt; une fonction qui permet de simuler une trajectoire d’un mouvement Brownien à un vecteur de temps fixés:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;simulate_brownian &amp;lt;- function(times){ # Simulation times
  n_points &amp;lt;- length(times) # Number of points
  brownian &amp;lt;- rep(NA, n_points) # Vector of outputs
  brownian[1] &amp;lt;- 0 # Initialization
  # Now, we simulate next positions thanks to the Brownian properties
  for(t in 2:n_points){
    # We use here the definition of the transition law
    next_mean &amp;lt;- brownian[t - 1] # Expectation of the transition law
    next_variance &amp;lt;- times[t] - times[t - 1] # Variance of the transition law
    # Now, we sample from a normal distribution
    brownian[t] &amp;lt;- rnorm(1, mean = next_mean, sd = sqrt(next_variance))
  }
  # Format the output in a data.frame
  output &amp;lt;- data.frame(t = times, b_t = brownian)
  return(output) 
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ainsi, on peut simuler une première trajectoire d’un Brownien:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;my_times &amp;lt;- seq(from = 0, to = 1, length.out = 1001) # Sequence of length 1001,
# starting from 0 and ending at 1
my_first_brownian &amp;lt;- simulate_brownian(times = my_times)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On peut la représenter visuellement à différents pas de temps &lt;span class=&#34;math inline&#34;&gt;\(\Delta\)&lt;/span&gt; (attention, il s’agit de la même trajectoire à différents pas de temps!).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../courses/2020_simu_inge_num/mouvement_brownien_files/figure-html/plot_brownian-1.png&#34; width=&#34;672&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remarque: &lt;/strong&gt; En &lt;code&gt;R&lt;/code&gt;, on peut simuler un mouvement Brownien de manière bien plus efficace (en termes de temps d’execution) sans faire de boucle de la manière suivante:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;simulate_brownian &amp;lt;- function(times){ # Simulation times
  n_points &amp;lt;- length(times) # Number of points
  # We can simulate all increments at once, and do the cumulative sum
  brownian &amp;lt;- c(0, cumsum(rnorm(n_points - 1, 0, sqrt(diff(times))))) # All in once!
  # Format the output in a data.frame
  output &amp;lt;- data.frame(t = times, b_t = brownian)
  return(output)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cette écriture, plus synthétique et plus efficace, n’est cependant pas générique, et ne peut pas être appliquée pour la simulation d’équations différentielles stochastiques que nous verrons par la suite.
Ainsi, on privilégiera la première écriture.&lt;/p&gt;
&lt;div id=&#34;loi-du-mouvement-brownien&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Loi du mouvement Brownien&lt;/h2&gt;
&lt;p&gt;En faisant plusieurs simulations, on peut vérifier empiriquement la propriété &lt;span class=&#34;math inline&#34;&gt;\(B(t) \sim \mathcal{N}(0, t)\)&lt;/span&gt;.
Sur le graphique suivant, on a effectué 500 simulations, et on regarde la distribution au temps &lt;span class=&#34;math inline&#34;&gt;\(t = 1\)&lt;/span&gt;.
On a tracé l’intervalle de confiance théorique à 95%.
On voit que la distribution empirique semble s’accorder avec la distribution théorique d’une loi Normale.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../courses/2020_simu_inge_num/mouvement_brownien_files/figure-html/simu_multiple_brownian-1.png&#34; width=&#34;672&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;De plus, on peut intuitivement valider deux propriétés du mouvement Brownien, chaque trajectoire est:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Continue (presque sûrement);&lt;/li&gt;
&lt;li&gt;Nulle part dérivable (presque sûrement).&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Exemple d&#39;équation différentielle stochastique</title>
      <link>/courses/2020_simu_inge_num/equation_differentielle_stochastique/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/courses/2020_simu_inge_num/equation_differentielle_stochastique/</guid>
      <description>


&lt;div id=&#34;modèle&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Modèle&lt;/h1&gt;
&lt;p&gt;On s’intéresse ici à l’équation différentielle stochastique:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\text{d}X(t) = \alpha X(t)(1 - X(t)^2) \text{d} s + \sigma \sqrt{1 + X(t)^2}\text{d} B(t),~X_0 = x_0.\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;On remarquera que la fonction &lt;span class=&#34;math inline&#34;&gt;\(f(x) = \alpha x(1 - x^2)\)&lt;/span&gt; satisfait la relation:
&lt;span class=&#34;math display&#34;&gt;\[f(x) =  \nabla_x u(x)\]&lt;/span&gt;
où &lt;span class=&#34;math inline&#34;&gt;\(u(x)\)&lt;/span&gt; est la fonction de potentiel &lt;span class=&#34;math inline&#34;&gt;\(u(x) = \alpha(\frac{x^2}{2} - \frac{x^4}{4})\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Pour &lt;span class=&#34;math inline&#34;&gt;\(\alpha = 1\)&lt;/span&gt;, ce potentiel est le suivant:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tibble(x = seq(-2, 2, length.out = 501)) %&amp;gt;% 
  ggplot(aes(x = x)) +
  stat_function(fun = get_potential) +
  labs(y = &amp;quot;u(x)&amp;quot;, title = &amp;quot;Double peak potential&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../courses/2020_simu_inge_num/equation_differentielle_stochastique_files/figure-html/plot_double_well-1.png&#34; width=&#34;672&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Ainsi, la direction préférentielle de la trajectoire est donnée par le gradient de cette fonction. On peut en déduire que les points &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt; et 1 seront deux points attractifs.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;simulation-avec-r&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Simulation avec R&lt;/h1&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse) 
# library(ggplot2); library(purrr); library(dplyr) 
# are enough if tidyverse doesn&amp;#39;t work&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nous allons maintenant coder en &lt;code&gt;R&lt;/code&gt; une fonction qui permet de simuler des trajectoires de cette EDS à paramètres et temps de simulation fixés.&lt;/p&gt;
&lt;p&gt;On commence par coder les fonctions de dérive et de diffusion, en explicitant la dépendance en les paramètres:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_drift &amp;lt;- function(x, alpha){
  alpha * x * (1 - x^2)
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_diffusion &amp;lt;- function(x, sigma){
  sigma * sqrt(1 + x^2)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ensuite on peut créer la fonction de simulation, qui dépendra de &lt;span class=&#34;math inline&#34;&gt;\(x_0\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt; et &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remarque:&lt;/strong&gt; Comme sortie de la fonction, on choisit un &lt;code&gt;tibble&lt;/code&gt; qui conserve les positions simulées ainsi que toutes les informations de simulation.
Cela permettra de faciliter les représentations graphiques plus tard:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;simulate_double_peak_sde &amp;lt;- function(times, # Simulation times
                                     x0, alpha, sigma) # Simulation parameters
  { 
  n_points &amp;lt;- length(times) # Number of points
  trajectory &amp;lt;- rep(NA, n_points) # Initialization of output trajectory
  trajectory[1] &amp;lt;- x0 # First position
  for(k in 2:n_points){ # Iteration
    h &amp;lt;- times[k] - times[k - 1] # Time step (must be small)
    euler_mean &amp;lt;- trajectory[k - 1] + # x
      get_drift(trajectory[k - 1], alpha) * h # drift(x) * h
    euler_variance &amp;lt;- get_diffusion(trajectory[k - 1], sigma)^2 * h 
    trajectory[k] &amp;lt;- rnorm(n = 1, # 1 gaussian sample
                       mean = euler_mean, # Mean
                       sd = sqrt(euler_variance) # Standard deviation
                       )
  }
  # Return tibble to ease later visualization
  tibble(t = times,
         x_t = trajectory,
         x0 = x0,
         alpha = alpha, 
         sigma = sigma)
}&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;simulation-simple&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Simulation simple&lt;/h2&gt;
&lt;p&gt;On peut ainsi simuler une première trajectoire, pour &lt;span class=&#34;math inline&#34;&gt;\(x_0 = 0,~\alpha = 1,~\sigma = 0.1\)&lt;/span&gt; et la représenter graphiquement:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(123) # For reproducibility
my_times &amp;lt;- seq(0, 15, by = 0.01) # Vecteur 0, 0.01, 0.02,...., 9.99, 10
simulate_double_peak_sde(times = my_times, # Simulation 
                         x0 = 0, alpha = 1, sigma = 0.1) %&amp;gt;% # Then
  ggplot(aes(x = t, y = x_t)) + # plot it
  geom_path() +
  labs(x = &amp;quot;Time&amp;quot;, y = &amp;quot;X(t)&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../courses/2020_simu_inge_num/equation_differentielle_stochastique_files/figure-html/plot_one_trajectory-1.png&#34; width=&#34;672&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Bien sûr, cette trajectoire n’est qu’une réalisation du processus, on peut regarder 30 réalisations:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(123) # For reproducibility
rerun(10, # Rerun 30 times the simulations
      simulate_double_peak_sde(times = my_times, # Simulation 
                         x0 = 0, alpha = 1, sigma = 0.1)) %&amp;gt;% # Then
  bind_rows(.id = &amp;quot;Replicate&amp;quot;) %&amp;gt;% # Aggregate it in a single tibble, keeping
  # track of the replicate identity
  ggplot(aes(x = t, y = x_t)) + # plot it
  geom_path(aes(group = Replicate), alpha = 0.5) + # Do a track per replicate
  labs(x = &amp;quot;Time&amp;quot;, y = &amp;quot;X(t)&amp;quot;,
       title = expression(&amp;quot;10 realizations for &amp;quot;~x(0)==0~alpha==1~sigma==0.1))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../courses/2020_simu_inge_num/equation_differentielle_stochastique_files/figure-html/plot_ten_trajectories-1.png&#34; width=&#34;672&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;On peut ainsi voir ici clairement apparaître nos deux points d’attractions.
On peut se demander si on peut passer de &lt;span class=&#34;math inline&#34;&gt;\(-1\)&lt;/span&gt; à 1?&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;influence-des-paramètres&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Influence des paramètres&lt;/h2&gt;
&lt;p&gt;On peut regarder les variations des trajectoires selon les paramètres.&lt;/p&gt;
&lt;p&gt;Ici les différents paramètres sont &lt;span class=&#34;math inline&#34;&gt;\(x_0\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt; et &lt;span class=&#34;math inline&#34;&gt;\(\sigma\)&lt;/span&gt;.
On voudrait tester &lt;span class=&#34;math inline&#34;&gt;\(x_0 = \lbrace -2, 0, 2\rbrace,~ \alpha = \lbrace 1, 5 \rbrace, \sigma = \lbrace 0.1, 0.5\rbrace\)&lt;/span&gt;, en testant toutes les combinaisons possibles (ici 12).&lt;/p&gt;
&lt;p&gt;Une manière concise et rapide de faire cela en &lt;code&gt;R&lt;/code&gt; est la fonction &lt;code&gt;pmap_dfr&lt;/code&gt; du package &lt;code&gt;purrr&lt;/code&gt;, qui prend en entrée une &lt;code&gt;tibble&lt;/code&gt; dont chaque ligne et renvoie un grand &lt;code&gt;tibble&lt;/code&gt; concaténant tous les résulats.&lt;/p&gt;
&lt;div id=&#34;création-du-plan-dexpérience&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Création du plan d’expérience&lt;/h3&gt;
&lt;p&gt;La première chose à faire est de créer le tableau des combinaisons de paramètres possibles, on
utilise pour cela la fonction &lt;code&gt;expand.grid&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# IMPORTANT: Columns names must be the same as argument names of the 
# simulation_double_peak_sde function
parameters_list &amp;lt;- expand.grid(x0 = c(-2, 0, 2), # x0s values
                               alpha = c(1, 3),
                               sigma = c(0.1, 0.5)) %&amp;gt;% # Creates the design grid
  as_tibble() # Turns it into a tibble&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Le tableau obtenu est le suivant:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 12 x 3
      x0 alpha sigma
   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
 1    -2     1   0.1
 2     0     1   0.1
 3     2     1   0.1
 4    -2     3   0.1
 5     0     3   0.1
 6     2     3   0.1
 7    -2     1   0.5
 8     0     1   0.5
 9     2     1   0.5
10    -2     3   0.5
11     0     3   0.5
12     2     3   0.5&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;simulations-sur-tout-le-plan-dexpérience&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Simulations sur tout le plan d’expérience:&lt;/h3&gt;
&lt;p&gt;Dans le code suivant, on teste les 12 combinaisons possibles. Pour chaque combinaison, on fait une simulation. Moralement, &lt;code&gt;pmap_dfr&lt;/code&gt; fait une boucle sur les 12 lignes du tableau précédent en concaténant le résultat dans un &lt;code&gt;tibble&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pmap_dfr(.l = parameters_list, # List of parameters
         .f = simulate_double_peak_sde, # Function to apply
         times = my_times # Additionnal arguments
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Comme on veut 10 simulations par jeu de paramètres, il suffit de répéter 10 fois ce code
grâce à &lt;code&gt;rerun&lt;/code&gt; et d’aggéger les résultats dans un &lt;code&gt;tibble&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(123) # For reproducibility
all_simulations &amp;lt;- rerun(10, # rerun 10 times
                         pmap_dfr(.l = parameters_list, # Same code as above
                                  .f = simulate_double_peak_sde, 
                                  times = my_times)
                         ) %&amp;gt;% # Then
  bind_rows(.id = &amp;quot;Replicate&amp;quot;) # Binds it a tibble, keeping track of replicate&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Le résultat est un &lt;code&gt;tibble&lt;/code&gt; de taille conséquente!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# A tibble: 180,120 x 6
   Replicate     t   x_t    x0 alpha sigma
   &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
 1 1          0    -2       -2     1   0.1
 2 1          0.01 -1.95    -2     1   0.1
 3 1          0.02 -1.90    -2     1   0.1
 4 1          0.03 -1.82    -2     1   0.1
 5 1          0.04 -1.78    -2     1   0.1
 6 1          0.05 -1.73    -2     1   0.1
 7 1          0.06 -1.67    -2     1   0.1
 8 1          0.07 -1.63    -2     1   0.1
 9 1          0.08 -1.62    -2     1   0.1
10 1          0.09 -1.61    -2     1   0.1
# … with 180,110 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;représentation-graphique&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Représentation graphique&lt;/h3&gt;
&lt;p&gt;On peut maintenant représenter graphiquement les différentes trajectoires simulées:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;all_simulations %&amp;gt;% # First we rename alphas and sigmas for nice rendering
  mutate(alpha = paste(&amp;quot;alpha ==&amp;quot;, alpha), 
         sigma = paste(&amp;quot;sigma ==&amp;quot;, sigma)) %&amp;gt;% 
  ggplot(aes(x = t, y = x_t)) + # Usual ggplot
  geom_path(aes(group = interaction(Replicate, x0), # Group trajectories
                color = factor(x0))) + # Color depending on starting point
  facet_wrap(.~ alpha + sigma, # One graph per combination alpha/sigma
             labeller = label_parsed) + # Turns names in maths
  labs(x = &amp;quot;Time&amp;quot;, y = &amp;quot;X(t)&amp;quot;, color = &amp;quot;X(0)&amp;quot;, # Labelling axis
       title = &amp;quot;Double peak potential SDE&amp;quot;)  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../courses/2020_simu_inge_num/equation_differentielle_stochastique_files/figure-html/plot_all_simulations-1.png&#34; width=&#34;672&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Ainsi, on peut constater que les trajectoires &lt;em&gt;peuvent passer d’un mode à l’autre&lt;/em&gt;. La fréquence de ces passages est fortement dépendante du rapport de force entre la dérive et la diffusionc autour des points d’attraction, soit ici:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\frac{\alpha x(1 - x^2)}{\sigma\sqrt{1 + x^2}}.\]&lt;/span&gt;
Ce rapport essentiel dans la théorie des EDS est parfois appelé &lt;strong&gt;rapport signal sur bruit&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
